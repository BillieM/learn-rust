# The Rust Systems Syllabus (Part 1: Stages 1 & 2)

## Stage 1: Ownership, Strings, and Basic Memory
**The Goal:** Unlearn the "Garbage Collector" mindset. Learn how Rust manages data life-cycles on the Stack and Heap.

| Project Idea | Domain | Concepts to Research | Extended Implementation Overview |
| :--- | :--- | :--- | :--- |
| **Brainfuck Interpreter** | Compilers | `Vec<u8>`, `match`, `u8` wrapping | You will implement a virtual machine with a 30,000-byte tape (a `Vec<u8>`). As you iterate through the program string, you’ll use a `match` statement to handle the 8 commands. The primary challenge is handling the `[` and `]` jump logic; you'll need to pre-parse the code to create a jump map or use a stack to find matching brackets. You must also use `wrapping_add` or `wrapping_sub` to ensure the tape pointer doesn't panic on overflow. |
| **Base64 Tool** | Data | Bit-shifting, `u8` slices, padding | This requires converting a stream of 8-bit bytes into 6-bit indices. You'll take an input slice `&[u8]`, iterate in chunks of three, and use bitwise shifts (`<<`, `>>`) and masks (`&`) to extract four 6-bit values. You then map these to the Base64 alphabet. The implementation forces you to think about "padding" (adding `=` characters) and how to return a newly allocated `String` from a function. |
| **BPM Metronome** | Audio/Time | `std::time`, `std::thread::sleep`, `f64` | Calculate the interval between beats in milliseconds based on a user-provided BPM. You’ll write a loop that calculates the exact time the *next* beat should occur, rather than just sleeping for a fixed duration, to prevent "drift." This teaches you how to work with `Instant` and `Duration`, and how to perform safe type casting between floating-point BPMs and integer milliseconds. |
| **IPv4 Subnet Calc** | Networking | `Ipv4Addr`, Bit-masking, `FromStr` | Parse a CIDR string into an `Ipv4Addr` struct. You will then convert that address into a `u32`, apply bitwise NOT and AND operations with the subnet mask to find the network and broadcast addresses, and convert them back into strings. This project highlights Rust's strong typing for network primitives compared to Go's more generic slices. |
| **Hex Dumper** | Systems | `std::fs::File`, `std::io::Read`, `format!` | Open a file and read it in 16-byte buffers using `read_exact`. For each buffer, you’ll print the current file offset in hex, the hex values of the bytes, and finally the ASCII representation. You’ll need to handle the `UnexpectedEof` error gracefully when the file isn't a perfect multiple of 16 bytes. This is your introduction to the `Read` and `BufRead` traits. |
| **Word Frequency** | CLI | `HashMap`, `Iterator` trait, `Entry` API | Parse a text file and count word frequency. You’ll learn about the `entry` API, which is the idiomatic Rust way to update a map value. You'll also learn to sort the final map by converting it into a `Vec` of tuples. This teaches you how ownership moves when inserting data into a collection. |
| **Simple RPN Calc** | Logic | `Stack` (using `Vec`), `parse`, `Result` | A Reverse-Polish Notation calculator. You’ll learn how to use a Vector as a stack. When an operator appears, you `pop()` the last two values, perform the math, and `push()` the result back. You’ll handle errors using `Result` to ensure the program doesn't panic on malformed input. |
| **ASCII Art Gen** | Graphics | Image luminance math, `u8` mapping | Read an image (use the `image` crate), iterate over pixels, and map the "brightness" (Luma) to a character in a string like `" .:-=+*#%@"`. You’ll learn about nested loops, mapping value ranges, and how to represent 2D pixel data in a flat 1D array. |
| **Checksummer** | Security | Streaming I/O, `Hasher` traits | Compute CRC32 or MD5 hashes of files. You’ll learn how to process files byte-by-byte using the `Read` trait without loading the entire file into memory. This teaches you about buffered I/O and stateful computations. |
| **TOML to JSON** | Web | `serde` crate, Struct attributes | Take a TOML file and output JSON. You will define a Rust `struct` that mirrors the data and use `serde`'s derive macros. This shows you how Rust handles structural data conversion at compile-time and how to use the `Result` type for parsing errors. |
| **Password Gen** | Security | `rand` crate, `Vec<char>`, shuffling | Generate secure strings based on user-defined complexity. You will learn how to integrate external crates, manage random seed states, and manipulate collections of characters efficiently. |
| **Markdown Linker** | Web | `Regex` crate, `&str` slicing, lifetimes | Use regex to find all `[text](url)` patterns in a file. You’ll learn about the `Regex` crate, how to extract "captures," and how Rust handles the lifetimes of strings found within a larger text block. |
| **Log Filter** | Data | String splitting, `Option` handling | Read a large log file line-by-line using `lines()`. If a line contains a specific keyword, print it. This teaches you about "Lazy Iterators" and how to process files that are larger than your available RAM. |
| **Unit Converter** | CLI | `Enums`, `FromStr` trait | A CLI for converting physical units. You'll use an `Enum` where variants can hold data (e.g., `Unit::Celsius(f64)`). This demonstrates how Rust Enums are more powerful than Go's `iota` constants. |
| **UUID v4 Gen** | Security | Bit-masking, `u128`, Randomness | Manually construct a 128-bit structure according to RFC 4122. You’ll use bit-masking to set the specific "version" and "variant" bits, then format it as a hex string with dashes. This teaches you low-level bit manipulation. |
| **Directory Tree** | Systems | `std::fs::read_dir`, Recursion, `PathBuf` | A recursive tool that prints a file tree. You’ll handle the `Path` and `PathBuf` types, which represent files in a cross-platform way, and learn how to handle "Permission Denied" errors during recursion. |
| **Morse Translator** | Data | `BTreeMap`, String building, `char` | Convert text to Morse and vice versa. Using `BTreeMap` instead of `HashMap` will teach you about ordered collections. You will also learn about efficient string concatenation using `String::with_capacity`. |
| **Env Audit** | Systems | `std::env`, Iterators, Filtering | A tool to list and filter environment variables. You'll learn how to work with iterators and adapters like `map`, `filter`, and `collect` to transform system-level data. |
| **Greyscale Tool** | Graphics | Binary I/O, `u8` buffers, color math | Read a `.bmp` file, calculate the average of R, G, and B for every pixel, and write the new values back. This is a lesson in how images are represented as flat arrays of bytes in memory. |
| **Sudoku Solver** | Logic | Backtracking, 2D Arrays, Recursion | A solver for Sudoku puzzles. This forces you to handle 2D indexing and mutable state across recursive function calls in a language where the borrow checker tracks every change. |

## Stage 2: Borrowing, Lifetimes, and References
**The Goal:** Stop cloning data. Learn how to let multiple parts of a program "see" memory using the `'a` lifetime syntax.

| Project Idea | Domain | Concepts to Research | Extended Implementation Overview |
| :--- | :--- | :--- | :--- |
| **Full MD Parser** | Web | `Peekable` iterators, Lifetimes `'a` | You'll build a parser that transforms Markdown syntax into HTML. Using a `Peekable` iterator, you will "peek" ahead to see if characters signify formatting. Your "Token" structs should contain references (`&str`) to the original input, forcing you to define explicit lifetime parameters. |
| **Static Server** | Web | `TcpListener`, `Path` security | Serve local files over HTTP. You’ll parse the raw HTTP request line to find the file path. The implementation must include a security check to ensure the path doesn't contain `..`, preventing directory traversal attacks. |
| **WAV Header Tool** | Audio | `Endianness`, `repr(C)`, Binary parsing | Define a `struct` that matches the 44-byte WAV header. You’ll use the `byteorder` crate to ensure you read values as "Little Endian." You will learn why Rust might reorder your struct fields unless you use the `#[repr(C)]` attribute. |
| **LRU Cache** | Data | `RefCell`, `Rc`, Doubly linked lists | Implement a cache that evicts old items. Because this requires nodes to point to each other, you’ll use `Rc<RefCell<Node>>` for "interior mutability." This is the classic "Rust hurdle" project for understanding smart pointers. |
| **TUI Editor** | CLI | `crossterm`, Event polling, Raw mode | Create a terminal-based editor. You'll use the `crossterm` crate to put the terminal into "raw mode" and manage a `Vec<String>` to represent lines. You'll learn to handle cursor movement and "scrolling" logic when files exceed screen size. |
| **DNS Packet Parser** | Networking | Bit-level manipulation, `Nom` crate | Parse the binary format of a DNS query/response. You'll use manual bit-shifting or a combinator library like `Nom` to extract 1-bit flags and 4-bit opcodes from raw UDP buffers. |
| **Tar Lister** | Systems | Offset-seeking, Binary headers | Read a `.tar` file and list its contents without extracting. You will use `std::io::Seek` to jump 512 bytes at a time based on header info, avoiding loading large file contents into RAM. |
| **Custom printf** | Systems | `macro_rules!`, Variadic-like behavior | Create a macro that formats strings. This introduces Rust’s declarative macro system, allowing you to write code that writes code, similar to how `println!` works. |
| **Lang Detector** | Data | N-grams, Static data, `include_str!` | Guess the language of a text block based on character frequency. You’ll learn how to embed large static frequency tables into your binary at compile time using the `include_str!` macro. |
| **Graph Library** | Data | Index-based graphs, `Generics` | Build a directed graph. Instead of using pointers, you will use an "Adjacency List" where nodes are stored in a `Vec` and edges are just indices (integers). This is the standard, safe way to build graphs in Rust. |
| **A* Pathfinding** | Logic | `PriorityQueue`, `Ord` trait | Find the shortest path on a grid. You’ll use a `BinaryHeap` and learn how to implement the `Ord` and `PartialOrd` traits so your structs can be sorted by priority in the queue. |
| **KV Store (TTL)** | Data | `TTL` logic, `Duration`, Shared state | An in-memory database where keys expire. You’ll store timestamps with your data and check for expiration on every request. This teaches you about time measurement and ownership of entries. |
| **SQL Lexer** | Compilers | State machines, Tokenization, `&str` | Tokenize a simple SQL statement. You’ll use a state machine (a `loop` with a `match` on characters). This teaches you how to navigate strings without allocating new memory for every token. |
| **Template Engine** | Web | String interpolation, Lifetimes | A tool that replaces `{{key}}` in a file. You’ll learn about "Lazy" string replacement and how to use lifetimes to ensure your template data stays alive as long as the engine needs it. |
| **Huffman Coding** | Compression | Binary trees, bit-vectors, `Seek` | Implement data compression via Huffman coding. You’ll build and traverse trees and learn to write data at the bit-level, which requires manual bit-buffering before writing to a `u8` file. |
| **RSS Aggregator** | Web | `reqwest` crate, XML parsing, `Result` | Fetch multiple XML feeds and merge them. You’ll learn about the `reqwest` crate for networking and how to map XML errors into a custom `Error` type for your application. |
| **File Watcher** | Systems | `notify` crate, OS signals, Callbacks | A tool that executes a command when a file changes. You’ll learn how Rust handles OS-level events and how to pass closures as callbacks to a library. |
| **JSON Path Eval** | Web | Recursive descent, Enums, `serde_json` | A tool to query JSON using paths like `data.users[0].name`. You'll navigate a recursive `serde_json::Value` enum, which is a great exercise in handling deeply nested optional data. |
| **TUI Dashboard** | CLI | `ratatui` crate, System metrics | A "htop" clone. You will learn about "Immediate Mode" GUI design and how to fetch system metrics (CPU/RAM) using the `sysinfo` crate and update the UI in a loop. |
| **Diff Tool** | Systems | LCS algorithm, Slice windows | Compare two files and show the differences. This focuses on the Longest Common Subsequence algorithm and efficient slice manipulation to minimize memory usage. |

## Stage 3: Fearless Concurrency
**The Goal:** Master multi-threading and asynchronous I/O. In Go, you have a runtime scheduler; in Rust, you have `Arc`, `Mutex`, and `Tokio`.

| Project Idea | Domain | Concepts to Research | Extended Implementation Overview |
| :--- | :--- | :--- | :--- |
| **Parallel Grep** | Systems | `Arc<T>`, `mpsc` channels, `std::thread` | You will build a tool that searches thousands of files in parallel. You’ll use an `Arc` (Atomic Reference Counter) to share the search string across threads. You'll implement a worker-pool pattern where a main thread feeds file paths into a channel and worker threads send "Match" structs back via another channel. This teaches you how to handle thread joining and the `Send/Sync` traits. |
| **TCP Proxy** | Network | `TcpStream`, `std::io::copy`, Bi-directional I/O | Build a proxy that forwards traffic from a local port to a remote server. For every connection, you’ll spawn two threads: one for "upstream" and one for "downstream." You must handle "half-close" scenarios where one side stops sending data but the other is still active. This teaches you how to manage the lifecycle of paired sockets and shared error states. |
| **Parallel Image Blur** | Graphics | `Rayon` crate, Data parallelism, Slicing | Instead of manual threads, you’ll use the `Rayon` crate to parallelize a Gaussian blur algorithm. You will take an image buffer, split it into horizontal chunks, and process them across all CPU cores. This project demonstrates how Rust’s ownership rules prevent "data races" when multiple threads try to write to different parts of the same pixel array. |
| **Async Port Scanner** | Network | `Tokio` runtime, `Futures`, `Semaphore` | Unlike the thread-based proxy, this uses async/await to scan 65,535 ports on a single thread. You’ll use a `Semaphore` to limit the number of active file descriptors so you don't crash the OS. You'll learn how to use `tokio::select!` to handle connection timeouts and successful hits simultaneously. |
| **Chat Server** | Web | WebSockets, `Arc<Mutex<HashMap>>` | Build a server where many clients can talk in real-time. You’ll store a map of active client "Sinks" (senders) inside a `Mutex`. When a message arrives, you must "lock" the map and iterate through every client to broadcast the message. This teaches you the cost of locking and how to structure shared-state applications. |
| **Blockchain Prototype** | Security | Hashing, PoW, Thread synchronization | Implement a basic chain where blocks are mined in parallel. You’ll have multiple threads competing to find a hash with a specific number of leading zeros. When one thread finds it, it must signal the others to stop. This teaches you about "Atomic" flags and shared immutable history. |
| **ID3 Tag Tool** | Media | `Seek` trait, Mutating buffers, Mutex | Read and write metadata for MP3 files. You'll implement a thread-safe file accessor that allows multiple threads to read tags but only one to write. You’ll learn about the `RwLock` (Read-Write Lock) and how to safely modify binary data in-place without corrupting the rest of the file. |
| **Redis Protocol Client** | Network | RESP Protocol, `BytesMut`, Async I/O | Build a client that talks to Redis using the RESP protocol. You’ll learn how to use a "Codec" to transform raw bytes from a socket into high-level Rust Enums. This project focuses on the "Framing" problem—handling cases where a single command is split across multiple TCP packets. |
| **Job Scheduler** | Systems | `Condvars`, Priority Queues, Threads | Create a system that runs tasks at specific times. You’ll use a `Condvar` (Condition Variable) to put a "Worker" thread to sleep until the next scheduled task is ready. This teaches you low-level thread synchronization that goes beyond simple mutexes. |
| **Load Balancer** | Web | Round-robin, Health checks, `Arc` | Distribute HTTP traffic across multiple backend servers. You’ll implement a background "Health Checker" thread that pings backends and updates an `Arc`-wrapped list of "Alive" servers. The main thread will then route traffic based on this shared state. |
| **Crypto Ticker** | Web | Async streams, JSON parsing, WebSockets | A live price feed tool. You’ll connect to an exchange API via WebSockets and process a continuous stream of JSON data. You’ll learn how to use "Streams" in Rust and how to perform asynchronous transformations (mapping/filtering) on live data. |
| **BitTorrent Downloader** | Network | P2P, Bitfields, Shared buffers | Implement the logic to download pieces of a file from different peers. You’ll manage a "Bitfield" that tracks which pieces you have. You’ll learn how to coordinate many threads writing to different offsets of the same physical file on disk. |
| **Parallel Web Crawler** | Web | `HashSet`, Recursive Async, `reqwest` | Crawl a domain and map all links. You’ll use an `Arc<Mutex<HashSet>>` to track visited URLs to avoid infinite loops. This project highlights the difficulty of recursive async functions and how to "box" futures to make them work. |
| **Audio Synthesizer** | Audio | `cpal` crate, Audio callbacks, Lock-free data | Generate a sine wave and play it. Audio threads are "real-time," meaning they cannot block or allocate memory. You’ll learn how to use a "Ring Buffer" to send data from a logic thread to an audio thread without using a Mutex. |
| **Raft Election Logic** | Distributed | RPCs, Timers, State machines | Implement the leader election part of the Raft consensus algorithm. You’ll manage "Terms" and "Votes" using timers that reset. This is a lesson in complex state management where many asynchronous events can happen at once. |
| **Distributed KV Store** | Data | Gossip protocol, Serialization | Multiple nodes syncing data. You’ll implement a "Gossip" loop where nodes randomly tell each other about their data. You’ll learn how to serialize Rust structs into binary to save bandwidth using `bincode`. |
| **ECS Game Engine Core** | Gaming | Generics, Type-safe storage | Build an Entity Component System. You’ll learn how to store different types of data (Position, Velocity) in contiguous memory for CPU cache efficiency. This involves heavy use of Rust Generics and possibly some "Interior Mutability." |
| **Multi-threaded Ray Tracer** | Graphics | Vector math, Scene graph | Render a 3D scene. You’ll divide the screen into "Tiles" and assign each tile to a thread. You'll learn how to manage a large, read-only scene graph that is shared by all rendering threads using `Arc`. |
| **Lisp Interpreter** | Compilers | Garbage Collection, ASTs | Build a Lisp. Since Lisp uses a lot of shared references, you’ll have to implement a basic reference-counting system or a "Mark and Sweep" collector. This teaches you the deep internals of memory management within Rust. |
| **Self-Updater** | Systems | OS Permissions, Process swap | A binary that replaces itself. You’ll learn to download a file, set execution bits, and use `std::process` to "Exec" the new version while terminating the old one. This involves platform-specific logic for Linux and Windows. |

## Stage 4: Low-Level and Unsafe
**The Goal:** Interact with the hardware and the OS directly. This is where you use raw pointers and bypass the Borrow Checker.

| Project Idea | Domain | Concepts to Research | Extended Implementation Overview |
| :--- | :--- | :--- | :--- |
| **Chip-8 Emulator** | Emulation | Memory mapping, Opcodes, bit-masking | You will define a `[u8; 4096]` array for RAM. You'll write a "Fetch-Decode-Execute" loop. Each opcode is 2 bytes; you'll use bitwise AND/SHR to extract register indices. You'll learn how to map virtual memory to real variables and how to implement a virtual timer. |
| **Memory Allocator** | Systems | `GlobalAlloc`, `mmap`, Raw pointers | You will write a `malloc` replacement. Using `unsafe` blocks, you’ll call `mmap` to get raw pages from the Kernel. You'll implement a "Free List" to track empty holes in your memory and a "First Fit" algorithm to assign chunks. This is a masterclass in pointer arithmetic. |
| **ls Clone (Syscalls)** | Systems | `libc` crate, FFI, File modes | Recreate `ls` by calling the C `stat` function. You’ll learn how to pass Rust strings to C (which requires a null-terminator) and how to interpret C bit-flags for file permissions. This teaches you the Foreign Function Interface (FFI). |
| **Process Top** | Systems | `/proc` filesystem, File parsing | A process monitor. On Linux, you’ll parse the `/proc/[pid]/stat` files to get CPU and RAM usage. You'll learn how to efficiently parse many small text files in a loop and how the OS exposes its state as a "fake" filesystem. |
| **Virtual File System** | Storage | Inodes, B-Trees, RAM-disk | Create an in-memory filesystem. You’ll define "Inodes" (metadata) and "Data Blocks." You’ll implement a directory structure where "Files" are just pointers to data blocks. This teaches you how operating systems actually organize your data on disk. |
| **Raw DNS Client** | Network | Raw UDP, Bit-packing, Packet headers | Construct a DNS query manually. You’ll create a `[u8; 512]` buffer and manually set bits for the "Recursion Desired" flag. You’ll learn how to pack a domain string (like `6google3com0`) into bytes without a helper library. |
| **JIT Compiler** | Compilers | `mprotect`, Machine code, Function pointers | Write a program that generates x86-64 machine code at runtime. You’ll allocate memory, write "Move" and "Add" instructions in hex, then use `mprotect` to make that memory executable. Finally, you'll cast the address to a Rust `fn` pointer and call it. |
| **USB Device Lister** | Hardware | `libusb`, FFI Bindings | Interface with a C library to talk to hardware. You’ll learn how to manage "Opaque Pointers" from C and how to ensure you call "Cleanup" functions (like `libusb_exit`) using the `Drop` trait in Rust to prevent leaks. |
| **Simple Bootloader** | OS | `no_std`, BIOS interrupts, 16-bit mode | Write a program that boots your computer. You’ll disable the standard library (`#![no_std]`) and write a `_start` function. You’ll use "Inline Assembly" (`asm!`) to call BIOS interrupts to print text to the screen before any OS even exists. |
| **VGA Driver** | OS | Volatile memory, Pointers, MMIO | Write text to the screen by writing to memory address `0xb8000`. You’ll use `ptr::write_volatile` to ensure the compiler doesn't "optimize away" your writes. This teaches you how Memory-Mapped I/O works. |
| **System Signal Handler** | Systems | Unix Signals, Signal stacks | Implement a program that handles `SIGINT` (Ctrl+C) or `SIGSEGV` customly. You’ll learn about the "Global" state in `unsafe` Rust and why handling signals is dangerous because they can interrupt your code at any microsecond. |
| **Custom Stack Trace** | Systems | Backtrace, DWARF format | Write a tool that prints the current function call stack. You’ll learn how to walk the "Stack Frames" using the base pointer and how to read the "Debug Symbols" inside your own binary to turn addresses into function names. |
| **NVMe Driver (Basic)** | Hardware | PCI-e, Registers, Command queues | A massive project where you talk to an NVMe SSD. You’ll learn about "Doorbell Registers" and how to set up "Submission Queues" in memory that the hardware reads directly via DMA (Direct Memory Access). |
| **Pipe Implementation** | Systems | Anonymous pipes, File descriptors | Implement a "Pipe" like the one used in `cat file \| grep`. You’ll use the `pipe` syscall and learn how to redirect `stdin` and `stdout` of child processes. This is essential for understanding how shells work. |
| **ELF Parser** | Compilers | Binary headers, Segment mapping | Read a Linux executable (ELF file) and print its sections. You’ll learn how code and data are separated in a binary and how the "Entry Point" address tells the OS where to start executing. |
| **User-space Threads** | Systems | Context switching, Green threads | Implement your own "Goroutines." You’ll manually save CPU registers to a buffer, swap the "Stack Pointer" to a new block of memory, and jump to a different function. This is the foundation of how Go's scheduler works. |
| **Raw Socket Sniffer** | Network | Promiscuous mode, Ethernet headers | Open a raw socket to see every packet entering your network card. You’ll manually parse Ethernet, IP, and TCP headers. This is a deep dive into the "Layer 2" and "Layer 3" of the networking stack. |
| **Page Table Walker** | OS | Virtual memory, CR3 register | Write a tool that translates a Virtual Address to a Physical Address by walking the 4 levels of x86-64 Page Tables. This is the ultimate lesson in how CPU memory isolation works. |
| **Serial Port Driver** | Hardware | UART, I/O ports | Talk to a Serial/COM port. You’ll use the `inb` and `outb` assembly instructions to send bytes one-by-one to a physical chip. This is the standard way to debug low-level kernels. |
| **Fuzz Tester** | Security | Instrumentation, Bit-flipping | Build a tool that randomly mutates input data to find crashes in a parser. You’ll learn how to track "Code Coverage" to see which parts of the code your random data has reached. |

## Stage 5: Hard Mode (Systems Architect)
**The Goal:** Build industrial-grade systems that manage their own resources, handle distributed consensus, or emulate complex hardware with high precision.

| Project Idea | Domain | Concepts to Research | Extended Implementation Overview |
| :--- | :--- | :--- | :--- |
| **LSM-Tree DB Engine** | Storage | WAL, SSTables, Bloom Filters | Build a storage engine like RocksDB. All writes go to an in-memory "MemTable" and a "Write-Ahead Log" for durability. When the MemTable is full, it's flushed to disk as a sorted "SSTable." You’ll implement a background "compaction" process that merges multiple SSTables and removes deleted keys. You'll use Bloom Filters to avoid unnecessary disk reads. |
| **Network Stack** | Networking | TUN/TAP, ARP, TCP State Machine | Implement a TCP/IP stack from scratch using a virtual network interface (TUN/TAP). You'll turn raw Ethernet frames into reliable data streams. This involves implementing the full TCP state machine (three-way handshake, congestion control, retransmission timers, and windowing). By the end, you should be able to route a real HTTP request through your own hand-coded stack. |
| **GameBoy Emulator** | Emulation | Cycle-accuracy, PPU, Memory Banking | Build a highly accurate GameBoy emulator. Unlike the Chip-8, the GameBoy requires "Cycle-Accuracy"—the CPU and the Pixel Processing Unit (PPU) must stay in perfect sync to render graphics correctly. You'll implement Memory Bank Controllers (MBCs) to handle cartridges larger than the address space and handle complex hardware interrupts for input and audio. |
| **Real-time OS (RTOS)** | OS | Context Switching, Scheduler, TCB | Create a tiny multitasking OS kernel. You’ll write the assembly code to perform "Context Switching" by saving and restoring CPU registers into a Task Control Block (TCB). You'll implement a priority-based scheduler and basic IPC (Inter-Process Communication) mechanisms like mailboxes or semaphores to allow tasks to coordinate without an underlying OS. |
| **Distributed DB** | Distributed | Raft/Paxos, Sharding, RPCs | Build a database that lives on a cluster of nodes. You’ll implement the Raft consensus algorithm to ensure that if the leader node fails, a new one is elected and the data remains consistent across the cluster. You will handle network partitions and "split-brain" scenarios where nodes lose connectivity but keep trying to process writes. |
| **Web Browser Engine** | Web | HTML/CSS Parsing, Layout, Painting | Build the core of a rendering engine. You’ll parse HTML into a DOM tree and CSS into a style tree. You’ll then implement the "Layout" engine, which calculates the exact geometry of every element (the Box Model). Finally, you'll implement a basic "Painter" that converts those geometries into a pixel buffer for display. |
| **C Compiler** | Compilers | LLVM IR, Lexing, AST Generation | Write a compiler that turns a subset of C into executable machine code. You’ll build a lexer and parser to create an Abstract Syntax Tree (AST), then perform type checking and semantic analysis. You'll use the LLVM library as a backend to handle machine-specific optimizations and code generation for x86 or ARM. |
| **GPU Path Tracer** | Graphics | Vulkan/WGPU, Shaders, Ray-tracing | Use the graphics card to render photo-realistic 3D scenes. You’ll move the heavy math from the CPU to the GPU by writing Compute Shaders. You'll implement a path-tracing algorithm that simulates light bouncing off surfaces to create realistic shadows, reflections, and global illumination. |
| **Zero-Knowledge Proofs** | Crypto | Finite Fields, SNARKs, Polynomials | Implement a cryptographic protocol like zk-SNARKs. This involves high-level mathematics (elliptic curves and polynomials) combined with low-level bit manipulation. You’ll build a system where a "Prover" can convince a "Verifier" that a statement is true without revealing any secret information. |
| **Flash File System** | Storage | Wear Leveling, Garbage Collection | Build a file system specifically for NAND Flash (like SD cards). Flash memory has a limited number of write cycles per block. You’ll implement "Wear Leveling" to distribute writes evenly across the hardware and a "Log-structured" design to ensure that writes are always made to empty blocks, optimizing for hardware longevity. |
| **Hypervisor (VMM)** | Virtualization | KVM, VT-x/AMD-V, VMCS | Write a simple Type-2 Hypervisor. You’ll use Linux's KVM API to set up virtual CPUs and memory. You’ll learn how to configure the Virtual Machine Control Structure (VMCS) to intercept "VM Exits"—sensitive instructions that the guest OS tries to execute which must be emulated by your host. |
| **Relational Query Optimizer** | Databases | Join Ordering, Cost Models, B-Trees | Build the "brain" of a SQL database. Given a query, your engine must decide the most efficient way to execute it (e.g., "Should I use an Index Scan or a Full Table Scan?"). You’ll implement a cost-based optimizer that uses table statistics to estimate the performance of different execution plans. |
| **Language VM** | Compilers | Bytecode, JIT, Garbage Collection | Create a virtual machine for a high-level language (like a mini-JVM or Python VM). You’ll design a custom bytecode format and an interpreter loop. To increase performance, you’ll implement a basic Just-In-Time (JIT) compiler that identifies "hot" functions and compiles them directly to machine code during execution. |
| **Distributed File System** | Storage | Metadata Servers, Data Stripping | Implement a system like HDFS or Lustre. You’ll separate file metadata (filenames, permissions) from the actual data blocks, which are stored across multiple "Data Nodes." You'll implement data replication so that if one server's hard drive fails, the file is still accessible from another node. |
| **High-Freq Trading Engine** | Finance | UDP Multicast, Order Matching, LOB | Build a Limit Order Book (LOB) that can handle millions of updates per second. You’ll use lock-free data structures and CPU pinning to minimize latency. You’ll learn how to parse binary exchange feeds (like NASDAQ ITCH) and match "Buy" and "Sell" orders with microsecond precision. |
| **Video Codec (H.264 subset)** | Media | DCT, Motion Compensation, Entropy | Implement a basic video decoder. You’ll learn how to perform Discrete Cosine Transforms (DCT) to compress image data and use "Motion Compensation" to only store the differences between consecutive frames. This project is a deep dive into heavy digital signal processing and bit-stream parsing. |
| **Garbage Collector** | Systems | Mark-and-Sweep, Immix, Safepoints | Write a stand-alone garbage collector that can be linked into other programs. You’ll implement a "Tracing" collector that starts from root pointers (on the stack) and finds all reachable memory. You’ll learn about the "Stop-the-World" problem and how to implement "Safepoints" where the program pauses for collection. |
| **Formal Verification Engine** | Security | SMT Solvers, Model Checking | Build a tool that proves your code is bug-free. You’ll convert Rust code into a mathematical model and use an SMT solver (like Z3) to check if there is any possible input that could cause a panic or a memory leak. This represents the absolute frontier of software reliability. |
| **Signal Processor** | Audio | FFT, IIR/FIR Filters, Windowing | Build a real-time audio effects processor. You’ll implement Fast Fourier Transforms (FFT) to analyze sound in the frequency domain and apply filters (like high-pass or low-pass). You’ll learn about "Latency Budgets"—if your code takes more than a few milliseconds to process, the audio will crackle. |
| **User-space USB Stack** | Hardware | EHCI/XHCI, HID, Bulk transfers | Write a driver that talks directly to the USB Controller hardware. You’ll bypass the OS's USB drivers and manually manage the "Asynchronous Schedule" of the USB controller. You'll learn how to perform "Handshaking" with a USB mouse or keyboard to get their raw input data. |
